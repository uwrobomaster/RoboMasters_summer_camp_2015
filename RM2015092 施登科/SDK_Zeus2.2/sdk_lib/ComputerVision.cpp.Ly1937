
///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 12.0.1
///////////////////////////////////////////////////////////////////////////////


#include"iostream"
#include"opencv2/core/core.hpp"
#include"opencv2/highgui/highgui.hpp"
#include"opencv2/imgproc/imgproc.hpp"
#include"time.h"

#include <libv4l2.h>
#include <linux/videodev2.h>
#include <fcntl.h>
#include <errno.h>

#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif
#include "sdk_lib/DJI_Control.h"
#include "sdk_lib/DJI_Pro_App.h"
#include "sdk_lib/DJI_Pro_Link.h"
#include "sdk_lib/DJI_Pro_Test.h"
#include "sdk_lib/Logic_CV_Thread.h"

#include "CV_header.h"
using namespace HalconCpp;
using namespace cv;
using namespace std;

//image from halcon to opencv
Mat halcon2opencv(HObject &img);
HObject opencv2halcon(Mat img);
// Procedures
// External procedures
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'.

HObject  ho_Img, ho_R, ho_G, ho_B, ho_Y, ho_U;
HObject  ho_V, ho_Img_yuv, ho_R_regions, ho_R_regionsDilation;
HObject  ho_RegionTrans, ho_Intersection1, ho_Img_yuvChannel21;
HObject  ho_Img_yuvChannel31, ho_opening, ho_closing, ho_Skeleton;
HObject  ho_LinesHNF, ho_SudokuErosion, ho_LinesSelected;
HObject  ho_LinesUnion, ho_LinesCircle, ho_ImageResult;
HObject   Hobj;
// Local control variables

HTuple  hv_FirstFlag, hv_PreAngle, hv_PreDist;
HTuple  hv_index, hv_Angle, hv_Dist, hv_SudokuArea, hv_SudokuRow;
HTuple  hv_SudokuColumn, hv_counter, hv_Angle_Norm, hv_Dist_Norm;
HTuple  hv_PreAngle_Norm, hv_PreDist_Norm, hv_PreAngle_Tuple;
HTuple  hv_PreDist_Tuple, hv_Distance, hv_Min, hv_TargetIndex;
HTuple  hv_exception,hv_CameraParam;
 HTuple  hv_AcqHandle;
 HTuple hv_pose ;
 HTuple hv_wcs_x,hv_wcs_y;
 HTuple hv_x0,hv_x1,hv_y0,hv_y1 ;

  Mat Imageresult;
  VideoCapture m_cap,m_cap1;
  //*************************************************************************************//
// Return Value To main thread
  float Angle_Return = 0;
  float Dist_Return = 0 ;

  //*************************************************************************************//
float x3,y3,x4,y4;
HObject opencv2halcon(Mat img)
{
  //HObject   Hobj;
  int height=img.rows;
  int width=img.cols;

//  printf("Channels = %d", img.channels()) ;
  if(img.channels()==1)
  {

  uchar *dataGray=new uchar[width*height];
  for(int i=0; i<height; i++)
  {
  memcpy(dataGray+width*i, img.datastart+width*i,width);
  }

  GenImage1(&Hobj,"byte",width,height,(Hlong)(dataGray));
  delete[ ] dataGray;
  return Hobj;
  }

  if(img.channels()==3)
  {
  Mat  IplImageRed(width,height,CV_8UC1), IplImageGreen(width,height,CV_8UC1), IplImageBlue(width,height,CV_8UC1);
  vector<Mat> channels;
  split(img,channels);
  IplImageBlue=channels.at(0);
  IplImageGreen=channels.at(1);
  IplImageRed=channels.at(2);
  uchar*  dataRed=new uchar[width*height];
  uchar*  dataGreen=new uchar[width*height];
  uchar*  dataBlue=new uchar[width*height];
  for(int i=0; i<height; i++)
  {
  memcpy(dataRed+width*i, IplImageRed.datastart+width*i,width);
  memcpy(dataGreen+width*i, IplImageGreen.datastart+width*i,width);
  memcpy(dataBlue+width*i, IplImageBlue.datastart+width*i,width);
  }

  GenImage3(&Hobj,"byte",width,height,(Hlong)(dataRed),(Hlong)(dataGreen),(Hlong)(dataBlue));
  delete[ ]  dataRed;
  delete[ ]  dataGreen;
  delete[ ]  dataBlue;
  }
  return Hobj;
}

//image from halcon to opencv
Mat halcon2opencv(HObject &img)
{
    HTuple hv_PointerRed,hv_PointerGreen,hv_PointerBlue,hv_Pointer;
    HTuple hv_Type,hv_width,hv_Height;
    HTuple num_channel;
    CountChannels(img,&num_channel);
    if(num_channel==3)
    {
    GetImagePointer3(img,&hv_PointerRed,&hv_PointerGreen,&hv_PointerBlue,&hv_Type,&hv_width,&hv_Height);
    int width,height;
    width=*hv_width.LArr();
    height=*hv_Height.LArr();

    Mat IplImage(height,width,CV_8UC3), IplImageRed(height,width,CV_8UC1), IplImageGreen(height,width,CV_8UC1), IplImageBlue(height,width,CV_8UC1);
    for(int i=0; i<height; i++)
    {
    memcpy(IplImageRed.datastart+width*i,(char *)hv_PointerRed[0].L()+width*i,width);
    memcpy(IplImageGreen.datastart+width*i,(char *)hv_PointerGreen[0].L()+width*i,width);
    memcpy(IplImageBlue.datastart+width*i,(char *)hv_PointerBlue[0].L()+width*i,width);
    }
    vector<Mat>channels(3);
    channels.at(0)=IplImageBlue;
    channels.at(1)=IplImageGreen;
    channels.at(2)=IplImageRed;
    merge(channels,IplImage);

    return IplImage;

    }
    else
    {
        GetImagePointer1(img,&hv_Pointer,&hv_Type,&hv_width,&hv_Height);
        int width,height;
        width=*hv_width.LArr();
        height=*hv_Height.LArr();
        Mat IplImage(height,width,CV_8UC1);
        for(int i=0; i<height; i++)
        {
        memcpy(IplImage.datastart+width*i,(char *)hv_Pointer[0].L()+width*i,width);
        }
        //imshow("gray",IplImage);
        return IplImage;
    }
    //imshow("G",IplImageGreen);
    //imshow("B",IplImageBlue);
    //waitKey(0);
}

void CV_Init()
{
    int m_width=640; // image size in pixels
    int m_height=480;
    Mat testimg;
 int ep;
 int VideoNum = 0;
    int m_deviceId=0; // camera id (in case of multiple cameras)

      hv_FirstFlag = 1;
    hv_PreAngle = (0/180.0)*3.1415926;
    hv_PreDist = 320.0;
/*Open Camera*/
    while(1)
  {
   printf("Input Video Num = \n") ;
   printf("0 Or 1 \n");
     scanf("%d",&VideoNum) ;
     ReadCamPar("/home/rm12/桌面/新建文件夹 (2)/RM_Camera.cal", &hv_CameraParam);

   if(VideoNum == 0)
     {
       cout << "1 \n"<<endl ;
 /*      m_cap=VideoCapture(0);
            waitKey(10) ;
       m_cap.release();
             waitKey(10) ;*/
       //m_cap1 = VideoCapture(0);
       //m_cap1.release();
       m_cap=VideoCapture(0);
         break ;
       }

       else if(VideoNum == 1)
      {//m_cap1 = VideoCapture(1);
       //m_cap1.release();
       m_cap=VideoCapture(1);
    //   m_cap.~VideoCapture();
   //    m_cap=VideoCapture(1);
       break ;
     }
    printf("Error Plear Input the data again \n") ;
   }
        if(!m_cap.isOpened()) {
      cerr << "ERROR: Can't find video device " << m_deviceId << "\n";
      exit(1);
    }

  /*       m_cap >> testimg;

             imshow("1",testimg) ;
             waitKey(10) ;
         cout<<"test channels = "<<testimg.channels()<<endl;
         if(testimg.channels() == 1)
             {
             cout<<"Open Video 0 Error ,Try to Open Video 1"<<endl ;
              m_cap=VideoCapture(1);

         } */

        m_cap.set(CV_CAP_PROP_FRAME_WIDTH, m_width);
    m_cap.set(CV_CAP_PROP_FRAME_HEIGHT, m_height);
    cout << "Camera successfully opened (ignore error messages above...)" << endl;
    cout << "Actual resolution: "
         << m_cap.get(CV_CAP_PROP_FRAME_WIDTH) << "x"
         << m_cap.get(CV_CAP_PROP_FRAME_HEIGHT) << endl;

}
extern sdk_std_msg_t recv_sdk_std_msgs;



void LineDetect()
{
    float Euler[4] ;
float x1,x2,y1=0,y2=480 ;
       float q_[4] ;

  // Local iconic variables


  // Local control variables


        //Image Acquisition 01: Do something

    //ReadImage(&ho_Img, "/home/dji/图片/IMG/Save5/image_"+(hv_index.TupleString(".4")));

    Decompose3(ho_Img, &ho_R, &ho_G, &ho_B);
    TransFromRgb(ho_R, ho_G, ho_B, &ho_Y, &ho_U, &ho_V, "yuv");
    Compose3(ho_Y, ho_U, ho_V, &ho_Img_yuv);
    Threshold(ho_Y, &ho_R_regions, 15, 250);
    DilationCircle(ho_R_regions, &ho_R_regionsDilation, 10);
    ShapeTrans(ho_R_regionsDilation, &ho_RegionTrans, "convex");

    Threshold(ho_Img_yuv, &ho_Intersection1, 192, 255);
    AccessChannel(ho_Img_yuv, &ho_Img_yuvChannel21, 2);
    //Note that the application of change_domain in the following is
    //safe because the new domains are calculated from the input image
    //and therefore are automatically consistent!
    ChangeDomain(ho_Img_yuvChannel21, ho_Intersection1, &ho_Img_yuvChannel21);
    Threshold(ho_Img_yuvChannel21, &ho_Intersection1, 102, 255);
    AccessChannel(ho_Img_yuv, &ho_Img_yuvChannel31, 3);
    ChangeDomain(ho_Img_yuvChannel31, ho_Intersection1, &ho_Img_yuvChannel31);
    Threshold(ho_Img_yuvChannel31, &ho_Intersection1, 0, 140);
    OpeningCircle(ho_Intersection1, &ho_opening, 3);
    OpeningCircle(ho_opening, &ho_opening, 3);

    ClosingCircle(ho_opening, &ho_closing, 3);
    OpeningCircle(ho_closing, &ho_opening, 3);
    Skeleton(ho_opening, &ho_Skeleton);
      //模式切换判断
 ErosionCircle(ho_opening, &ho_SudokuErosion, 50);
    AreaCenter(ho_SudokuErosion, &hv_SudokuArea, &hv_SudokuRow, &hv_SudokuColumn);
    CountObj(ho_SudokuErosion, &hv_counter);
    if (0 != (HTuple(hv_SudokuArea[0])>30000))
    {
      hv_SudokuRow += 1;
    }
    //hough_lines (Skeleton, 4, 1000, 10, 500, Angle, Dist)
  //  printf("4 \n") ;
    try
    {
      HoughLines(ho_Skeleton, 4, 100, 200, 100, &hv_Angle, &hv_Dist);
      GenRegionHline(&ho_LinesHNF, hv_Angle, hv_Dist);

      if (0 != hv_FirstFlag)
      {
        //*             for i := 0 to |Angle|-1 by 1
        //均一化

        hv_Angle_Norm = hv_Angle/(2*3.1415926);
        hv_Dist_Norm = hv_Dist/800;
        hv_PreAngle_Norm = hv_PreAngle/(2*3.1415926);
        hv_PreDist_Norm = hv_PreDist/800.0;
        TupleGenConst(hv_Angle.TupleLength(), hv_PreAngle_Norm, &hv_PreAngle_Tuple);
        TupleGenConst(hv_Dist.TupleLength(), hv_PreDist_Norm, &hv_PreDist_Tuple);

        DistancePp(hv_Angle_Norm, hv_Dist_Norm, hv_PreAngle_Tuple, hv_PreDist_Tuple,
            &hv_Distance);
        TupleMin(hv_Distance, &hv_Min);

     //   cout<<*hv_Min.DArr()<<endl;

        if(    *hv_Min.DArr() >0.20 )
        {

            hv_PreAngle = (0/180.0)*3.1415926;
            hv_PreDist = 320.0;
            hv_PreAngle_Norm = hv_PreAngle/(2*3.1415926);
            hv_PreDist_Norm = hv_PreDist/800.0;
            TupleGenConst(hv_Angle.TupleLength(), hv_PreAngle_Norm, &hv_PreAngle_Tuple);
            TupleGenConst(hv_Dist.TupleLength(), hv_PreDist_Norm, &hv_PreDist_Tuple);

            DistancePp(hv_Angle_Norm, hv_Dist_Norm, hv_PreAngle_Tuple, hv_PreDist_Tuple,
                &hv_Distance);
            TupleMin(hv_Distance, &hv_Min);

         }

        q_[0] =recv_sdk_std_msgs.q.q0;
        q_[1] =recv_sdk_std_msgs.q.q1;
        q_[2] =recv_sdk_std_msgs.q.q2;
        q_[3] =recv_sdk_std_msgs.q.q3;
        q2e(q_, Euler   ) ;

        TupleFind(hv_Distance, hv_Min, &hv_TargetIndex);
        GenRegionHline(&ho_LinesSelected, HTuple(hv_Angle[hv_TargetIndex]), HTuple(hv_Dist[hv_TargetIndex]));

        hv_PreAngle = ((const HTuple&)hv_Angle)[hv_TargetIndex];
        hv_PreDist = ((const HTuple&)hv_Dist)[hv_TargetIndex];

        hv_pose.Clear() ;
        hv_pose[0] = 0 ;
        hv_pose[1] = 0;
        hv_pose[2] =  recv_sdk_std_msgs.pos.height ;
        hv_pose[3] = Euler[1] ;
        hv_pose[4] = Euler[2] ;
        hv_pose[5] = 0 ;
        hv_pose[6] = 0 ;
        x1 = (hv_PreDist - y1 * sin(*hv_PreAngle.DArr()) ) / cos(*hv_PreAngle.DArr()) ;
        x2 = (hv_PreDist - y2 * sin(*hv_PreAngle.DArr()) ) / cos(*hv_PreAngle.DArr()) ;



        ImagePointsToWorldPlane(hv_CameraParam,hv_pose,(HTuple(y1).Append(y2)) ,(HTuple(x1).Append(x2)),"m",&hv_wcs_x,&hv_wcs_y);
      hv_x0 = ((const HTuple&)hv_wcs_x)[0];
         hv_x1 = ((const HTuple&)hv_wcs_x)[1];
         hv_y0 = ((const HTuple&)hv_wcs_y)[0];
            hv_y1 = ((const HTuple&)hv_wcs_y)[1];
    //    cout<<"Point 0 :"<<* hv_x0.DArr()<< "  " <<* hv_y0.DArr() <<"Point 1 :"<<* hv_x1.DArr()<< "  " <<* hv_y1.DArr() <<endl;
x3=* hv_x0.DArr();
y3=* hv_y0.DArr();
x4=* hv_x1.DArr();
y4=* hv_y1.DArr();



     //   cout<<*hv_wcs_y[0]<< "" <<*hv_wcs_y[1]<<endl;

        //cout<<((const HTuple&)hv_wcs_x)[0]<< " "<< ((const HTuple&)hv_wcs_x)[1]<<endl;
        //cout<<((const HTuple&)hv_wcs_y)[0]<< " "<< ((const HTuple&)hv_wcs_x)[1]<<endl;
      }
      Union1(ho_LinesSelected, &ho_LinesUnion);
      DilationCircle(ho_LinesUnion, &ho_LinesCircle, 3);

      PaintRegion(ho_LinesCircle, ho_Img, &ho_ImageResult, ((HTuple(255).Append(0)).Append(0)),
          "fill");


     // Dist_Return =( *hv_PreDist.DArr()  - sin(*hv_PreAngle.DArr() ) * 240 ) / cos(*hv_PreAngle.DArr() ); //x
        Dist_Return = (x3+x4)/2 ;
        Angle_Return = *hv_PreAngle.DArr() *180 / 3.1415926;

      Imageresult=halcon2opencv(ho_ImageResult);




   //    cout<<"Angle:  "<< Angle_Return <<"   Dist:  "<< (Dist_Return-320) <<endl;


      //cout<<Imageresult.rows<<"  "<<Imageresult.cols<<endl;

    }

    catch (HalconCpp::HException &HDevExpDefaultException)
    {
        HDevExpDefaultException.ToHTuple(&hv_exception);
    // cout<<hv_exception<<endl ;
        Imageresult=halcon2opencv(ho_Img);
//cout <<"No line Detected"<<endl ;

 //     HDevExpDefaultException.ToHTuple(&hv_exception);
    }
  return  ;
}
void CV_End()
{
       CloseAllFramegrabbers();
 }
void Grab_Image()
{
    static int frame = 0;

    Mat img;
    char imgname[16];
    m_cap >> img;

    if(img.empty())
    {
        cout<< "  NI MA BI"<<endl ;
        cout<<"Image Channels ="<<img.channels()<<endl ;
        return;
    }
    sprintf(imgname,"img_%.4d.jpg",frame);
    cv::imwrite(imgname,img);
    ho_Img=opencv2halcon(img);
 frame ++ ;

    //cout<< "  NI MA BI"<<endl ;
}
void CV_Show(int state)
{
/*char line[32];
sprintf(line,"line=%.4f,%.4f",Angle_Return,Dist_Return);
Point point_line=Point(400,100);
putText(Imageresult,line,point_line,FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),2,8);
char point_real1[32];
sprintf(point_real1,"point_real1=(%.4f,%.4f)",* hv_x0.DArr(),* hv_y0.DArr());
Point real_point1=Point(400,150);
putText(Imageresult,point_real1,real_point1,FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),2,8);
char point_real2[32];
sprintf(point_real2,"point_real2=(%.4f,%.4f)",* hv_x1.DArr(),* hv_y1.DArr());
Point real_point2=Point(400,200);
putText(Imageresult,point_real2,real_point2,FONT_HERSHEY_SIMPLEX,0.5,Scalar(0,0,255),2,8);
*/
  //    cout<<Imageresult.cols<<"     11111"<<endl;
      imshow("result",Imageresult);
      waitKey(10) ;

}

void ExposureChange(int value)
{
    int m_exposure=value;
int m_deviceId=0;
      string video_str = "/dev/video0";
      video_str[10] = '0' + m_deviceId;

   int device = v4l2_open(video_str.c_str(), O_RDWR | O_NONBLOCK);
      if (m_exposure >= 0) {
        // not sure why, but v4l2_set_control() does not work for
        // V4L2_CID_EXPOSURE_AUTO...
        struct v4l2_control c;
        c.id = V4L2_CID_EXPOSURE_AUTO;
        c.value = 1; // 1=manual, 3=auto; V4L2_EXPOSURE_AUTO fails...
        if (v4l2_ioctl(device, VIDIOC_S_CTRL, &c) != 0) {
          cout << "Failed to set... " << strerror(errno) << endl;
        }
        cout << "exposure: " << m_exposure << endl;
        v4l2_set_control(device, V4L2_CID_EXPOSURE_ABSOLUTE, m_exposure*6);
      }

      v4l2_close(device);




}
