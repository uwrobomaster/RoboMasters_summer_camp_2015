///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 12.0.1
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'. 
void dev_update_on ();

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'on'. 
void dev_update_on ()
{

  //This procedure sets different update settings to 'on'.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Img, ho_R, ho_G, ho_B, ho_Y, ho_U;
  HObject  ho_V, ho_image_yuv, ho_ImageMean, ho_R_skeleton;
  HObject  ho_Result, ho_SelectedRegions, ho_Skeleton, ho_ROI_0;
  HObject  ho_TMP_Region, ho_Union, ho_Closing, ho_WithOutLine;
  HObject  ho_ClosingUnion, ho_RegionFillUp, ho_RegionDifference;
  HObject  ho_c, ho_ObjectSelected, ho_Rectangle, ho_Contours;
  HObject  ho_ObjectSelected1;

  // Local control variables
  HTuple  hv_CameraParam, hv_FirstFlag, hv_PreAngle;
  HTuple  hv_PreDist, hv_Row_pre, hv_Column_pre, hv_Index;
  HTuple  hv_Area, hv_Row, hv_Column, hv_Row_const, hv_Column_const;
  HTuple  hv_Distance, hv_DistanceMin, hv_Indices_MinIndex;
  HTuple  hv_Pose, hv_X, hv_Y1, hv_Row1, hv_Column1, hv_Phi;
  HTuple  hv_Length1, hv_Length2, hv_Pose1, hv_CovPose, hv_Error;
  HTuple  hv_NumOfPose1, hv_exception;


  //Image Acquisition 01: Code generated by Image Acquisition 01


  ReadCamPar("/home/rm12/桌面/新建文件夹 (2)/RM_Camera (copy).cal", &hv_CameraParam);
  hv_FirstFlag = 1;
  hv_PreAngle = (0/180.0)*3.1415926;
  hv_PreDist = 320.0;
  hv_Row_pre = 240;
  hv_Column_pre = 320;
  {
  HTuple end_val10 = 8000-1;
  HTuple step_val10 = 1;
  for (hv_Index=497; hv_Index.Continue(end_val10, step_val10); hv_Index += step_val10)
  {
    try
    {

      ReadImage(&ho_Img, "/home/rm12/图片/Image2/img_"+(hv_Index.TupleString(".4")));
      Decompose3(ho_Img, &ho_R, &ho_G, &ho_B);
      TransFromRgb(ho_R, ho_G, ho_B, &ho_Y, &ho_U, &ho_V, "yuv");
      Compose3(ho_Y, ho_U, ho_V, &ho_image_yuv);
      MeanImage(ho_V, &ho_ImageMean, 20, 20);
      DynThreshold(ho_ImageMean, ho_V, &ho_R, 15, "dark");
      Skeleton(ho_R, &ho_R_skeleton);
      Connection(ho_R, &ho_Result);
      SelectShape(ho_Result, &ho_SelectedRegions, "area", "and", 322.16, 2000);
      Skeleton(ho_SelectedRegions, &ho_Skeleton);
      GenRectangle1(&ho_ROI_0, 0, 10, 2, 630);
      GenRectangle1(&ho_TMP_Region, 10, 638, 470, 640);
      Union2(ho_ROI_0, ho_TMP_Region, &ho_ROI_0);
      GenRectangle1(&ho_TMP_Region, 478, 10, 480, 630);
      Union2(ho_ROI_0, ho_TMP_Region, &ho_ROI_0);
      GenRectangle1(&ho_TMP_Region, 417.911, -0.5, 418.889, -0.5);
      Union2(ho_ROI_0, ho_TMP_Region, &ho_ROI_0);
      GenRectangle1(&ho_TMP_Region, 10, 0, 470, 2);
      Union2(ho_ROI_0, ho_TMP_Region, &ho_ROI_0);


      Union1(ho_SelectedRegions, &ho_Union);
      ClosingCircle(ho_Union, &ho_Closing, 50);
      ConcatObj(ho_Closing, ho_ROI_0, &ho_WithOutLine);
      Union1(ho_WithOutLine, &ho_ClosingUnion);

      FillUp(ho_ClosingUnion, &ho_RegionFillUp);

      Difference(ho_RegionFillUp, ho_ClosingUnion, &ho_RegionDifference);
      Connection(ho_RegionDifference, &ho_c);
      AreaCenter(ho_c, &hv_Area, &hv_Row, &hv_Column);
      TupleGenConst(hv_Area.TupleLength(), hv_Row_pre, &hv_Row_const);
      TupleGenConst(hv_Area.TupleLength(), hv_Column_pre, &hv_Column_const);
      DistancePp(hv_Row, hv_Column, hv_Row_const, hv_Column_const, &hv_Distance);


      TupleMin(hv_Distance, &hv_DistanceMin);
      TupleFind(hv_Distance, hv_DistanceMin, &hv_Indices_MinIndex);
      hv_Row_pre = ((const HTuple&)hv_Row)[hv_Indices_MinIndex];
      hv_Column_pre = ((const HTuple&)hv_Column)[hv_Indices_MinIndex];


      SelectObj(ho_c, &ho_ObjectSelected, hv_Indices_MinIndex+1);

      hv_Pose.Clear();
      hv_Pose[0] = 0;
      hv_Pose[1] = 0;
      hv_Pose[2] = 1.4;
      hv_Pose.Append((0.00586824*180)/3.1415926);
      hv_Pose.Append((-0.000999202*180)/3.1415926);
      hv_Pose.Append(0);
      hv_Pose.Append(0);
      ImagePointsToWorldPlane(hv_CameraParam, hv_Pose, hv_Row, hv_Column, "m", &hv_X, 
          &hv_Y1);
      SmallestRectangle2(ho_c, &hv_Row1, &hv_Column1, &hv_Phi, &hv_Length1, &hv_Length2);
      GenRectangle2(&ho_Rectangle, hv_Row1, hv_Column1, hv_Phi, hv_Length1, hv_Length2);
      GenContourRegionXld(ho_Rectangle, &ho_Contours, "border");
      SelectObj(ho_Contours, &ho_ObjectSelected1, 1);
      GetRectanglePose(ho_Contours, hv_CameraParam, 0.46, 0.46, "nonweighted", 2, 
          &hv_Pose1, &hv_CovPose, &hv_Error);
      hv_NumOfPose1 = hv_Pose1.TupleLength();
      if (0 != (HTuple(hv_Area[0])!=0))
      {
        // stop(); only in hdevelop
        //a := Row[1]
      }

      dev_update_on();
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Img, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Rectangle, HDevWindowStack::GetActive());
      dev_update_off();


    }
    // catch (exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_exception);
      dev_update_on();
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Img, HDevWindowStack::GetActive());
      dev_update_off();
    }


    // stop(); only in hdevelop
    //wait_seconds (0.1)



  }
  }

}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


